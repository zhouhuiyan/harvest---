<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>查看原文</title>
    <link href="css/bootstrap.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
</head>
<body>
<div class="bg-grey PLR40">

    <div class="paper-txt P30">
        <p class="text-idt25" data-id="1">基于vue的个人博客的设计与实现</p><p class="text-idt25" data-id="2">姓名：周会艳</p><p class="text-idt25" data-id="3">院系：信息工程学院</p><p class="text-idt25" data-id="4">专业：计算机科学与技术</p><p class="text-idt25" data-id="5">导师：郑颖</p><p class="text-idt25" data-id="6">完成时间：2019-00-00</p><p class="text-idt25" data-id="7">题目</p><p class="text-idt25" data-id="8">摘要：</p><p class="text-idt25" data-id="9">互联网成为了当今世界人们对外交流，快速获取、发布和传递信息的最常用也是最便捷的渠道，互联网在人们生活、工作与学习的方方面面都发挥着重要的作用。而博客网站正适应这种人际与技术交流方式的改变，满足个人技术与信息共享的需求。本文对博客的功能与需求进行了完整分析，设计出了一个简单、易用的个人博客系统。为了提高开发效率和代码复用率，本系统使用采用SPA（单页面应用）思想的vue.js进行系统的开发。Vue.js是一个轻量级的基于MVVM模式的渐进式框架。组件与数据绑定思想，简化了前端开发的复杂度。后端将node.js技术与express结合使用，以创建符合RESTful API设计规范的接口。实现前后端分离，有效的进行了解耦。</p><p class="text-idt25" data-id="10">关键词 博客，vue.js ，node.js ，前端框架</p><p class="text-idt25" data-id="11">英文题目</p><p class="text-idt25" data-id="12">有道的：</p><p class="text-idt25" data-id="13">Abstract: the Internet has become the most common and convenient channel for people to communicate with others in the world. The Internet plays an important role in people’s life， work and study. Blog sites are adapting to this change in interpersonal and technical communication， to meet the needs of personal technology and information sharing. This article has carried on the complete analysis to the blog function and the demand， has designed a simple， easy to use personal blog system. In order to improve the development efficiency and code reuse rate， This system uses the idea of SPA (single page application) vue. Js to develop system . Vue. js is a lightweight progressive framework based on the MVVM pattern. The idea of component and data binding simplifies the complexity of front-end development. The back end USES node.js technology in conjunction with express to create interfaces that conform to RESTful API design specifications. The front and rear ends are separated and decoupled effectively.</p><p class="text-idt25" data-id="14">关键词</p><p class="text-idt25" data-id="15">开发背景8</p><p class="text-idt25" data-id="16">1.1博客的背景8</p><p class="text-idt25" data-id="17">1.2系统设计的意义9</p><p class="text-idt25" data-id="18">系统相关技术介绍9</p><p class="text-idt25" data-id="19">SPA（Single Page App）9</p><p class="text-idt25" data-id="20">单页应用9</p><p class="text-idt25" data-id="21">与传统网页的比较9</p><p class="text-idt25" data-id="22">单页应用的好与坏11</p><p class="text-idt25" data-id="23">NPM11</p><p class="text-idt25" data-id="24">2.1vue.js12</p><p class="text-idt25" data-id="25">2.1.1介绍12</p><p class="text-idt25" data-id="26">Vue-cli12</p><p class="text-idt25" data-id="27">2.2.1声明式渲染13</p><p class="text-idt25" data-id="28">2.2.1创建实例14</p><p class="text-idt25" data-id="29">2.2.2 vue响应式原理16</p><p class="text-idt25" data-id="30">2.2.5 与其他框架相比优点17</p><p class="text-idt25" data-id="31">2.2路由17</p><p class="text-idt25" data-id="32">2.3状态管理17</p><p class="text-idt25" data-id="33">axios :19</p><p class="text-idt25" data-id="34">2.4node.js19</p><p class="text-idt25" data-id="35">2.4.1Node.js模块系统20</p><p class="text-idt25" data-id="36">Node.js Express 框架20</p><p class="text-idt25" data-id="37">2.4Node.js GET/POST请求20</p><p class="text-idt25" data-id="38">2.3Node.js RESTful API20</p><p class="text-idt25" data-id="39">2.4Node.js 连接 MySQL20</p><p class="text-idt25" data-id="40">系统分析20</p><p class="text-idt25" data-id="41">3.1需求分析20</p><p class="text-idt25" data-id="42">3.23.2 可行性分析21</p><p class="text-idt25" data-id="43">系统设计21</p><p class="text-idt25" data-id="44">前台21</p><p class="text-idt25" data-id="45">后台21</p><p class="text-idt25" data-id="46">数据库设计21</p><p class="text-idt25" data-id="47">概念结构设计21</p><p class="text-idt25" data-id="48">逻辑结构设计21</p><p class="text-idt25" data-id="49">系统实现22</p><p class="text-idt25" data-id="50">序言</p><p class="text-idt25" data-id="51">Blog（博客）作为一种个人知识管理工具，在人们日常生活中越来越盛行</p><p class="text-idt25" data-id="52">互联网成为人们快速获取、发布和传递信息的重要渠道，它在人们政治、经济、生活等各个方面发挥着重要的作用。通用博客技术的出现使得每个人可以零成本、零维护地创建自己的网络媒体， Blog站点所形成的网状结构促成了不同于以往社区的 Blog文化， Blog技术缔造了“博客”文化。通用博客是当今网络的热点，越来越多的网民开始将自己的想法、感受、心情等以文字、图片或多媒体的形式发布到网络中，以便于与朋友或其他浏览者分享，而博客正是承载这些内容的平台。所以开发出一个高效的通用博客系统，使越来越多的人更能方便、快捷的向别人展示自己。</p><p class="text-idt25" data-id="53">博客(Blogger)的出现，使我们在互联网世界，第一次有了知识积累和文化指向。使人类由粗放的数字化生存，过渡为个人化的精确的目录式生存。博客们将工作、生活和学习融为一体，通过博客日志( Blog)，将日常的思想精华及时记录并发布，萃取并链接全球最有价值、最相关、最有意思的信息与资源。在其形成的博客媒介下，更多的知识工作者能够零距离、零壁垒地汲取这些最鲜活的思想。博客传播的出现，标志着以“信息共享”为特征的第一代门户之后，追求“思想共享”为特征的第二代门户正在浮现，互联网开始真正凸现无穷的知识价值。博客传播是网络传播领域出现的个性鲜明的传播现象，其出现改变了网络传播的秩序，重新划分了网络传播的界限。博客的出现还打破了长久以来传统媒体对媒介所传播内容的控制，使得由美国社会心理学家、传播学四大先驱之一的卢因1947年率先提出的“把关人”理论受到强烈冲击，以至于更有甚者宣称，“守门人”时代结束。一个理论的建立，在某种意义上讲是现实实践的结论升华，它反过来必然要指导实践活动。一个理论的结束，对于现实生活是具有重大意义的。博客技术下发展起来的博客群体、博客媒介和博客传播，是否将重新定义互联网的界限...</p><p class="text-idt25" data-id="54">博客是以自由、开放和共享为文化特征，通过图文音象等表现形式，围绕个人网络存在的五大功能，提供存取读写、组织沟通、评价交换等服务的一种社会化个人服务模式。它并不是纯粹的技术创新，但确是一种逐渐演变的网络应用，一种形式的变化。从某种意义上说，也是一种计算机源代码开放，它像一部傻瓜照相机一样，让所有使用者都成了程序员，这就大大消解了网络与人的距离，也消解了人与人的距离。博客的全民性，让它的传播方式成为所有人对所有人的传播。然而，博客并不如表面般繁荣，当博客毫不掩饰地在大众面前喧闹的时候，接踵而来的问题使得博客乱了方寸。本文以非独立博客网站为研究对象，从传者、受者、内容、博客服务平台以及互动反馈等几个方面对博客进行分析，并从中得出了以下结论:博客参与者的盲目性导致了博客行为过程中的迷茫与厌倦;由于进入的零门槛和缺少监管，彻底颠覆互联网既有模式的博客，变成了新的信息垃圾场。博客正遭受低俗肤浅成风、网络侵权等因素的困扰；博客平台在服务、管理以及价值导向上忽略了用户体验；博客间的互动也呈现两个极端的尴尬局面。从总体上说，我国博客正处在一个混乱期，隐藏在虚热表面下的是种种的危机。</p><p class="text-idt25" data-id="55">开发背景</p><p class="text-idt25" data-id="56">1.1博客的背景</p><p class="text-idt25" data-id="57"> Blog是继 Email、 BBS、 ICQ之后出现的第四种网络交流方式，至今为止十分受大家的欢迎，是网络时代的个人“读者文摘”，是以超级链接为入口的网络日记，是代表着新的生活方式和新的工作方式，更代表着新的学习方式。简言之， Blog就是以网络作为载体，简易迅速便捷地发布自己的心得，及时有效轻松地与他人进行交流，再集丰富多彩的个性化展示于一体的综合性平台。</p><p class="text-idt25" data-id="58">博客的分类有很多。比如，按功能分：基本博客、微型博客；按用户分：个人博客、企业博客；按存在方式分：托管博客、自建独立网站的Blogger、附属Blogger、独立博客。本系统就是按用户划分的个人博客。</p><p class="text-idt25" data-id="59">博客有以下特点：</p><p class="text-idt25" data-id="60">简单的操作是博客开发的动力。 这是博客收到众多网友青睐的最大特点。许多博客托管网站使用的口号就是“一分钟内就可以轻松拥有一个博客”。</p><p class="text-idt25" data-id="61">2、不断更新的功能是博客生活的催化剂。现代社会，信息传递超级快速，更新博客可以比作生物的新陈代谢，生物没有新陈代谢就代表着生命的终结，而博客没有更新，博客也就失去了生命力。</p><p class="text-idt25" data-id="62">3、开放互动功能是博客传播的推动。网络赋予了博客的开放性，博客也就不再是一个纯粹的私人空间。游客与博主给我们的文章写留言与评论，如果我们对他们进行了回复，并通过链接地址进行回访，就达到了互动效应。因此，利用博客开放互动的特点，可以用于交流推广，形成一个固定的博客朋友圈。</p><p class="text-idt25" data-id="63">4、展示个性的特点是博客精彩的原动力。博主可以简单地从日志内容，博客界面，文章数量，日志分类体现出博主的个性。</p><p class="text-idt25" data-id="64">1.2系统设计的意义</p><p class="text-idt25" data-id="65">在科技快速进步的今天，互联网成为了当今世界人们对外交流，快速获取、发布和传递信息的最常用也是最便捷的渠道，互联网在人们生活、工作与学习的方方面面都发挥着重要的作用。当今时代，技术日新月异，作为互联网技术从业者，需要不断的汲取新知识，走在技术的前沿，但是大部分新技术文档与书籍都是英文，对于英语能力有限的互联网技术从业者，不可避免的需要借助搜素引擎或者其他人的帮助，在搜索引擎的搜索结果中大部分的技术问题解决方案的贡献者都来自博客，所以此次毕业设计自己也想要做一个记录自己学习与工作过程的心得体会的博客网站，去适应这种人际与技术交流方式的改变，同时也实现个人技术与信息共享的需求。</p><p class="text-idt25" data-id="66">系统相关技术介绍</p><p class="text-idt25" data-id="67">SPA（Single Page App）</p><p class="text-idt25" data-id="68">单页应用</p><p class="text-idt25" data-id="69">单页应用（英语： single- page application，缩写 SPA）是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。在单页应用中，所有必要的代码（ HTML、 JavaScript和 CSS）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）由路由程序动态装载适当的资源并添加到页面。网站所有的页面内容都包含在这个主页面中。但是在实际开发的时候，还是会分开写（页面片段）。 SPA可支持丰富的客户端功能，很少需要重新加载整个页面因此当用户执行操作或在应用的各区域间导航时无需重新加载页面，所以加载速度更快，可在后台提取数据，并且对单个用户操作的响应更快。</p><p class="text-idt25" data-id="70">与传统网页的比较</p><p class="text-idt25" data-id="71">为了更好的理解什么是单页应用，我们先来了解传统的网页应用。传统网页应用的工作模式如下图</p><p class="text-idt25" data-id="72">/</p><p class="text-idt25" data-id="73">传统网页应用的工作模式</p><p class="text-idt25" data-id="74">目前绝大部分的网站都还采用这种形式。将单个 HTML 页面作为功能元件，通过刷新，超链接、表单提交等方式，组合排列这些 HTML 页面，来为用户提供服务。此种方式作为网页应用的传统形式长久不衰，很多流行的开发框架都以之作为范式设计的。比如 Ruby on Rails，Spring MVC，Express 等等</p><p class="text-idt25" data-id="75">/</p><p class="text-idt25" data-id="76">传统网页应用的工作分布</p><p class="text-idt25" data-id="77">在传统的网页应用中，浏览器更多的是充当一个展示层，路由处理、服务调用、页面跳转流程都由服务端来处理。即 MVC 都放在服务器端，而 V 作为用户界面则通过网络发送到浏览器端，作为 UI 与用户交互。</p><p class="text-idt25" data-id="78">这样的范式有以下特点：</p><p class="text-idt25" data-id="79">重服务端，由于 MVC 都存在于服务器上，因此这类应用在开发资源和开发的重心都偏向后端，往往是后端工程师来主导整个项目开发；</p><p class="text-idt25" data-id="80">页面频繁刷新，由于浏览器端只是一个展现层，当页面功能有所变化的时，页面就刷新，这会导致资源的浪费，用户需要花费额外的时间等待页面刷新，用户体验不佳。</p><p class="text-idt25" data-id="81">相较于传统网页应用，单页应用将 MVC 前置到了浏览器端：</p><p class="text-idt25" data-id="82">/</p><p class="text-idt25" data-id="83">单页应用的工作分布</p><p class="text-idt25" data-id="84">1控制器前置，单页应用将路由处理放在浏览器端，即在浏览器端直接响应浏览器地址的变化，分发到对应的路由，向用户呈现对应的界面。</p><p class="text-idt25" data-id="85">2以小块组件为功能元件，类似于传统网页中的 Ajax组件，单页应用以小的组件为功能元件，在路由变化时，不再刷新整个页面，而是组合这些小的组件，替换变化的部分。</p><p class="text-idt25" data-id="86">3数据层前置，与 Ajax组件一个明显的区别是，单页应用在浏览器端通常有一层实实在在的数据层，而服务端则退化成了完全的数据 API。浏览器端的数据层会封装服务端 API，供上层的视图层调用。</p><p class="text-idt25" data-id="87">单页应用的好与坏</p><p class="text-idt25" data-id="88">每种技术都有其利弊，单页应用也是如此。单页面开发的优点：</p><p class="text-idt25" data-id="89">1良好的用户体验：用户不需要重新刷新页面，减少TTFB的请求耗时，获取数据也是通过Ajax异步获取，页面显示流畅。</p><p class="text-idt25" data-id="90">2前后端分离：前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起。</p><p class="text-idt25" data-id="91">3减轻服务端压力：减轻服务器压力，服务器只需要提供API接口，不用管页面逻辑和页面的拼接，吞吐能力会提高几倍。</p><p class="text-idt25" data-id="92">4共用一套后端程序代码，适配多端：同一套后端程序代码，不用修改就可以适用于Web、手机、平板。</p><p class="text-idt25" data-id="93">5组件共享：某些对性能体验要求不高的场景，或者产品处于快速试错阶段，借助于一些技术（ Hybrid、 React Native），可以在多端共享组件，便于产品的快速迭代，节约资源。</p><p class="text-idt25" data-id="94">单页面开发的缺点：</p><p class="text-idt25" data-id="95">1首屏加载过慢：单页面首次加载，需要将所有页面所依赖的css和js 合并后统一加载，所 以css和js文件会较大，影响页面首次打开时间。</p><p class="text-idt25" data-id="96">2 SEO：因为页面数据都是前端异步加载的方式，不利于搜索引擎的抓取。</p><p class="text-idt25" data-id="97">如果应用要求包括丰富的功能，且超出了典型 HTML 窗体提供的功能，则应选择 SPA 样式应用程序。</p><p class="text-idt25" data-id="98">NPM</p><p class="text-idt25" data-id="99">由于使用到的技术都是通过npm来安装的，所以先来介绍npm到底是什么：</p><p class="text-idt25" data-id="100">NPM 即 Node 包管理器（Node Package Manager）。它是一个以 JavaScript 编写的软件包管理系统，默认环境为 Node.js，从 Node.js 0.6.3 版本开始，NPM 被自动附带在安装包中。能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p><p class="text-idt25" data-id="101">允许用户从NPM服务器下载别人编写的第三方包到本地使用。</p><p class="text-idt25" data-id="102">允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p><p class="text-idt25" data-id="103">允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p><p class="text-idt25" data-id="104">使用npm安装包的命令是：npm install 包名 [--save-dev]</p><p class="text-idt25" data-id="105">--save与-dev都是可选的</p><p class="text-idt25" data-id="106">--save: 将安装的包放在依赖项dependencies中</p><p class="text-idt25" data-id="107">--save-dev:安装的包将出现在devDependencies中</p><p class="text-idt25" data-id="108">2.1vue.js</p><p class="text-idt25" data-id="109">2.1.1介绍</p><p class="text-idt25" data-id="110">Vue 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><p class="text-idt25" data-id="111">/</p><p class="text-idt25" data-id="112">Vue.js中View与Model的交互原理</p><p class="text-idt25" data-id="113">此图不仅描述了MVVM模式（Model-View_ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的。</p><p class="text-idt25" data-id="114">ViewModel是Vue.js的核心，它是一个Vue实例。Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。</p><p class="text-idt25" data-id="115">当创建了ViewModel后，双向绑定是如何达成的呢？</p><p class="text-idt25" data-id="116">首先，我们将上图中的DOM Listener和Data Bindings看作两个工具，它们是实现双向绑定的关键。</p><p class="text-idt25" data-id="117">View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据。</p><p class="text-idt25" data-id="118">从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。</p><p class="text-idt25" data-id="119">2.2.1 组件化应用构建</p><p class="text-idt25" data-id="120">组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。在网页构建中几乎任意类型的应用界面都可以抽象为一个组件树：</p><p class="text-idt25" data-id="121">/</p><p class="text-idt25" data-id="122">页面结构的树形示意</p><p class="text-idt25" data-id="123">2.2.2 vue响应式原理</p><p class="text-idt25" data-id="124">Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接。 Vue 响应式系统的底层的细节如下图：</p><p class="text-idt25" data-id="125">/</p><p class="text-idt25" data-id="126">vue响应式原理</p><p class="text-idt25" data-id="127">vue如何追踪变化呢？当把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。由于Object.defineProperty 是ES5中一个无法 shim 的特性，所以 Vue 不支持 IE8 及以下低版本的浏览器。这些 getter/setter 对用户来说是不可见的，但是在内部 Vue 通过它们追踪依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter被调用时，会通知 watcher重新计算，从而致使它关联的组件得以更新。这就是vue响应式更新组件的原理。</p><p class="text-idt25" data-id="128">2.2.5 与其他框架相比优点</p><p class="text-idt25" data-id="129">1易用。只要已经学会了 HTML、CSS、JavaScript就可以阅读vue开发指南开始构建应用。不像其他前端框架一样有比较高的使用门槛。</p><p class="text-idt25" data-id="130">2.灵活。不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。</p><p class="text-idt25" data-id="131">Vue-cli</p><p class="text-idt25" data-id="132"> Vue- cli是 vue官方开发的脚手架工具，基于 webpack构建，很好地规范了其开发生态，开发者只需要关注业务代码本身，而不必操心复杂的 webpack配置，可以说是对开发人员尤其是新手是相当友好的。</p><p class="text-idt25" data-id="133">Vue CLI 是一个基于 Vue.js 进行快速开发的完整系统，提供了以下功能：</p><p class="text-idt25" data-id="134">1通过 @vue/cli 搭建交互式的项目脚手架。</p><p class="text-idt25" data-id="135">2通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发。</p><p class="text-idt25" data-id="136">3一个运行时依赖 (@vue/cli-service)，该依赖：</p><p class="text-idt25" data-id="137">1.可升级；</p><p class="text-idt25" data-id="138">2基于 webpack 构建，并带有合理的默认配置；</p><p class="text-idt25" data-id="139">3可以通过项目内的配置文件进行配置；</p><p class="text-idt25" data-id="140">4可以通过插件进行扩展。</p><p class="text-idt25" data-id="141">5一个丰富的官方插件集合，集成了前端生态中最好的工具。</p><p class="text-idt25" data-id="142">6一套完全图形化的创建和管理 Vue.js 项目的用户界面。</p><p class="text-idt25" data-id="143">上边提到了webpack，那么什么是webpack呢？请看以下介绍：</p><p class="text-idt25" data-id="144"> webpack就是前端资源模块化管理和打包工具，它可以将很多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源，还可以将按需加载的模块进行代码分割，等到实际需要的时候再异步加载（如图），而要它自动实现这些功能，你得提前编辑好配置文件。</p><p class="text-idt25" data-id="145">/</p><p class="text-idt25" data-id="146">用vue项目来举例：浏览器它是只认识js，不认识vue的。而我们写的代码后缀大多是.vue的，在每个.vue文件中都可能html、js、css甚至是图片资源；并且由于组件化，这些.vue文件之间还有错综复杂的关系。所以项目要被浏览器识别，我们就要使用webpack将它们打包成js文件以及相应的资源文件。</p><p class="text-idt25" data-id="147">或者这么理解，我们以vue项目的形式编写项目逻辑，浏览器以他理解的方式来运行项目。webpack把我们的vue项目想表达的所有意图传递给浏览器让浏览器去运行。WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（ less， TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><p class="text-idt25" data-id="148">2.2路由</p><p class="text-idt25" data-id="149">本系统的前端路由使用vue-router来实现。</p><p class="text-idt25" data-id="150">vue-router是一个前端路由管理器，是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。</p><p class="text-idt25" data-id="151">2.3状态管理</p><p class="text-idt25" data-id="152">Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。本系统使用vuex来进行系统组件之前公共数据的管理。</p><p class="text-idt25" data-id="153">vuex是一种集中式状态管理模式，什么意思呢？我们在模块化开发过程中，我们以组件来作为模块单位，模块之间存在于不同的命名空间，作用域互不干预，这样保证了我们模块之间变量函数名称等不会冲突，但是有时候我们我们需要组件之间共享一些数据或者状态，通常用传参来实现，但是传参的做法至少有两个弊端，一是麻烦(尤其是当需要传递的参数很多时)，二是不好管理且冗余(给多个组件传参就需要多份参数列表，而且容易出错)。 vuex提供的集中式管理就解决了这个问题，通过把要共享的数据或状态集中起来管理，别的组件需要时就去访问变更，大大提高了可维护性和开发效率。</p><p class="text-idt25" data-id="154">/</p><p class="text-idt25" data-id="155">vuex状态管理流程</p><p class="text-idt25" data-id="156">需要注意，所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。</p><p class="text-idt25" data-id="157">axios :</p><p class="text-idt25" data-id="158">2.4node.js</p><p class="text-idt25" data-id="159">Node.js是一个事件驱动I/O的能够在服务器端运行JavaScript的开放源代码、跨平台JavaScript运行环境。Node.js由Node.js基金会持有和维护[4]，并与Linux基金会有合作关系[5]。Node.js采用Google开发的V8运行代码，使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的即时应用程序。</p><p class="text-idt25" data-id="160">Node.js大部分基本模块都用JavaScript语言编写。在Node.js出现之前，JavaScript通常作为客户端程序设计语言使用，以JavaScript写出的程序常在用户的浏览器上运行。Node.js的出现使JavaScript也能用于服务端编程。Node.js含有一系列内置模块，使得程序可以脱离Apache HTTP Server或IIS，作为独立服务器运行。</p><p class="text-idt25" data-id="161">2.4.1Node.js模块系统</p><p class="text-idt25" data-id="162">http://www.runoob.com/nodejs/nodejs-module-system.html</p><p class="text-idt25" data-id="163">什么是模块系统</p><p class="text-idt25" data-id="164">什么是模块?</p><p class="text-idt25" data-id="165">模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。每个模块都有自己的作用域，当我们使用 var 来申明的一个变量，他并不是全局的，而是属于当前模块下。</p><p class="text-idt25" data-id="166">模块是构建应用程序的基础，也使得函数和变量私有化，不直接对外暴露出来，接下来我们就要介绍Node的模块化系统和它最常用的模式。JavaScript起初并没有内置的模块系统，CommonJS社区为了使JavaScript可以提供一个类似Python、Ruby等的标准库，自己实现了一套API填补了JavaScript没有内置模块的空白。</p><p class="text-idt25" data-id="167"> CommonJS规范本身涵盖了模块、二进制、 Buffer、文件系统、包管理等内容，而 NodeJS正是借鉴了 CommonJS规范的模块系统，自身实现了一套非常易用的模块系统。CommonJS对模块的定义可分为三部分：模块引用（require）、模块定义（exports、module）、模块标识。</p><p class="text-idt25" data-id="168">为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。模块可以通过 module.exports 自由地隐藏内部实现、对外暴露接口 。我们只需要通过 require，就能实现模块加载引入。</p><p class="text-idt25" data-id="169">在Node.js 中创建模块</p><p class="text-idt25" data-id="170">// add.js</p><p class="text-idt25" data-id="171">functionadd(a，b){</p><p class="text-idt25" data-id="172">returna+b}</p><p class="text-idt25" data-id="173">module.exports={</p><p class="text-idt25" data-id="174">add}</p><p class="text-idt25" data-id="175">当我们需要在其他地方使用 add 方法时，比如：</p><p class="text-idt25" data-id="176">// app.jsconst{add}=require(’./add’)</p><p class="text-idt25" data-id="177">console.log(add(1，2))// 3</p><p class="text-idt25" data-id="178">我们只需要调用 require(’./add’) 就能实现对模块的引入。</p><p class="text-idt25" data-id="179">Node.js Express 框架</p><p class="text-idt25" data-id="180">Express 是一个简洁而灵活的 node.js Web应用框架， 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。Express 框架核心特性如下：</p><p class="text-idt25" data-id="181">1可以设置中间件来响应 HTTP 请求。</p><p class="text-idt25" data-id="182">2定义了路由表用于执行不同的 HTTP 请求动作。</p><p class="text-idt25" data-id="183">3可以通过向模板传递参数来动态渲染 HTML 页面。</p><p class="text-idt25" data-id="184">4丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单</p><p class="text-idt25" data-id="185">5 性能更好。Express 在node.js 上扩展了Web应用所需的功能</p><p class="text-idt25" data-id="186">安装 Express 并将其保存到依赖列表中：</p><p class="text-idt25" data-id="187">$ npm install express --save</p><p class="text-idt25" data-id="188">2.4Node.js GET/POST请求</p><p class="text-idt25" data-id="189">http://www.runoob.com/nodejs/node-js-get-post.html</p><p class="text-idt25" data-id="190">在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。表单提交到服务器一般都使用 GET/POST 。</p><p class="text-idt25" data-id="191">Node.js获取GET请求内容：由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。node.js 中 url 模块中的 parse 函数提供了这个功能。parse函数的作用是解析url，返回一个json格式的数组</p><p class="text-idt25" data-id="192">/</p><p class="text-idt25" data-id="193">获取get参数</p><p class="text-idt25" data-id="194">获取 POST 请求内容：POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的 POST请求会大大消耗服务器的资源，所以 node. js默认是不会解析请求体的，当你需要的时候，需要手动来做。</p><p class="text-idt25" data-id="195">/</p><p class="text-idt25" data-id="196">获取post请求</p><p class="text-idt25" data-id="197">2.3Node.js RESTful API</p><p class="text-idt25" data-id="198">REST全称是Representational State Transfer，中文意思是表述（编者注：通常译为表征）性状态转移。 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一。 他在论文中提到：”我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。REST指的是一组架构约束条件和原则。” 如果一个架构符合REST的约束条件和原则，我们就称它为RESTful架构。</p><p class="text-idt25" data-id="199"> REST本身并没有创造新的技术、组件或服务，而隐藏在 RESTful背后的理念就是使用 Web的现有特征和能力，更好地使用现有 Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p><p class="text-idt25" data-id="200">2.4Node.js 连接 MySQL</p><p class="text-idt25" data-id="201">连接数据库代码如图所示，其中connect()方法用来创建连接，end()方法用来关闭连接，query()方法用来向mysql传递参数。</p><p class="text-idt25" data-id="202">/</p><p class="text-idt25" data-id="203">连接mysql数据库</p><p class="text-idt25" data-id="204">系统分析</p><p class="text-idt25" data-id="205">3.1需求分析</p><p class="text-idt25" data-id="206">想要完成一个系统，需求分析是第一步，明确系统是什么，要干什么，完成那些功能。</p><p class="text-idt25" data-id="207">本系统需求如下：</p><p class="text-idt25" data-id="208">博客的游客用户可以在网站上对文章进行常规访问。以及在通过注册登录后，可以进行文章的发布与发表评论。博主可以通过后台对用户进行管理以及文章与文章分类添加、删除、修改。</p><p class="text-idt25" data-id="209">针对博客系统的以上需求，总结出如下信息：</p><p class="text-idt25" data-id="210">1.用户分为游客、普通用户和超级管理用户。</p><p class="text-idt25" data-id="211">2.超级管理用户员可以用户进行管理和设置权限。</p><p class="text-idt25" data-id="212">3.博客的超级管理员涉及对博客的文章类型管理、文章管理、评论管理、和用户管理。</p><p class="text-idt25" data-id="213">4.用户可以阅读文章、发表评论，游客只能进行文章的阅读。</p><p class="text-idt25" data-id="214">5.一种文章类型可以有多篇文章，一篇文章可以有多条评论。</p><p class="text-idt25" data-id="215">3.23.2 可行性分析</p><p class="text-idt25" data-id="216">可行性分析( Feasibility Analysis)是在系统调查的基础上，针对新系统的开发是否具备必要性和可能性，对新系统的开发从技术、经济、社会的方面进行分析和研究，以避免投资失误，保证新系统的开发成功。可行性研究的目的就是用最小的代价在尽可能短的时间内确定问题是否能够解决。为了确定开发具有可行性，对本系统主要进行了以下几个方面的分析。</p><p class="text-idt25" data-id="217">技术可行性分析：本人对于VUE.JS与NODE.JS在实习中有所接触，对这方面有所了解，所以从技术方面看做个人博客是可行的。</p><p class="text-idt25" data-id="218">时间可行性：现在博客技术已经非常成熟，多方面的问题都有成熟的解决方案，结合技术可行性，在预定的时间里可以完成此次设计。</p><p class="text-idt25" data-id="219">系统设计</p><p class="text-idt25" data-id="220">/</p><p class="text-idt25" data-id="221">个人博客的总体规划图如下：</p><p class="text-idt25" data-id="222">/</p><p class="text-idt25" data-id="223">前台</p><p class="text-idt25" data-id="224">在前台，游客浏览首页，文章详情页，文章列表与文章分类，注册用户在此基础上可以对文章进行评论。</p><p class="text-idt25" data-id="225">/</p><p class="text-idt25" data-id="226">后台</p><p class="text-idt25" data-id="227">超级管理员通过预设的账号登录后台。超级管理员可以在后台对文章进行增删查改，对文章分类进行增删查改，对评论进行查看和删除；对注册用户进行管理，可以进行的操作有查看和封禁。</p><p class="text-idt25" data-id="228">/</p><p class="text-idt25" data-id="229">数据库设计</p><p class="text-idt25" data-id="230">数据库是个人博客设计的主要部分，本系统选用了mysql数据库，使用navicat premium可视化数据库管理工具进行数据库的设计与管理。</p><p class="text-idt25" data-id="231">概念结构设计</p><p class="text-idt25" data-id="232">/</p><p class="text-idt25" data-id="233">对于属性比较多的实体，在E_R图中只列出了部分属性以做示意，具体的详细设计将体现在数据库表的结构中。如下图所以：</p><p class="text-idt25" data-id="234">数据库概念结构e-r图</p><p class="text-idt25" data-id="235">逻辑结构设计</p><p class="text-idt25" data-id="236">/</p><p class="text-idt25" data-id="237">根据数据的概念结构设计为基础，设计出如下表结构</p><p class="text-idt25" data-id="238">（1）用户表管理用户的信息。表结构设计如下：</p><p class="text-idt25" data-id="239">字段名称</p><p class="text-idt25" data-id="240">数据类型</p><p class="text-idt25" data-id="241">字段长度</p><p class="text-idt25" data-id="242">说明</p><p class="text-idt25" data-id="243">id</p><p class="text-idt25" data-id="244">int</p><p class="text-idt25" data-id="245">5</p><p class="text-idt25" data-id="246">用户ID(主键)</p><p class="text-idt25" data-id="247">account</p><p class="text-idt25" data-id="248">varchar</p><p class="text-idt25" data-id="249">50</p><p class="text-idt25" data-id="250">登录名</p><p class="text-idt25" data-id="251">password</p><p class="text-idt25" data-id="252">varchar</p><p class="text-idt25" data-id="253">50</p><p class="text-idt25" data-id="254">密码</p><p class="text-idt25" data-id="255">pwd_salt</p><p class="text-idt25" data-id="256">int</p><p class="text-idt25" data-id="257">5</p><p class="text-idt25" data-id="258">密码加盐随机数</p><p class="text-idt25" data-id="259">nickname</p><p class="text-idt25" data-id="260">varchar</p><p class="text-idt25" data-id="261">50</p><p class="text-idt25" data-id="262">用户名字</p><p class="text-idt25" data-id="263">birthday</p><p class="text-idt25" data-id="264">date</p><p class="text-idt25" data-id="265">20</p><p class="text-idt25" data-id="266">出生日期</p><p class="text-idt25" data-id="267">gender</p><p class="text-idt25" data-id="268">tinyint</p><p class="text-idt25" data-id="269">1</p><p class="text-idt25" data-id="270">性别</p><p class="text-idt25" data-id="271">introduce</p><p class="text-idt25" data-id="272">varchar</p><p class="text-idt25" data-id="273">200</p><p class="text-idt25" data-id="274">个人介绍</p><p class="text-idt25" data-id="275">status</p><p class="text-idt25" data-id="276">tinyint</p><p class="text-idt25" data-id="277">1</p><p class="text-idt25" data-id="278">用户状态</p><p class="text-idt25" data-id="279">role_id</p><p class="text-idt25" data-id="280">int</p><p class="text-idt25" data-id="281">5</p><p class="text-idt25" data-id="282">角色id</p><p class="text-idt25" data-id="283">角色表</p><p class="text-idt25" data-id="284">字段名称</p><p class="text-idt25" data-id="285">数据类型</p><p class="text-idt25" data-id="286">字段长度</p><p class="text-idt25" data-id="287">说明</p><p class="text-idt25" data-id="288">id</p><p class="text-idt25" data-id="289">int</p><p class="text-idt25" data-id="290">5</p><p class="text-idt25" data-id="291">角色ID(主键)</p><p class="text-idt25" data-id="292">name</p><p class="text-idt25" data-id="293">varchar</p><p class="text-idt25" data-id="294">20</p><p class="text-idt25" data-id="295">角色名称</p><p class="text-idt25" data-id="296">dest</p><p class="text-idt25" data-id="297">varchar</p><p class="text-idt25" data-id="298">20</p><p class="text-idt25" data-id="299">角色描述</p><p class="text-idt25" data-id="300">permission_list</p><p class="text-idt25" data-id="301">varchar</p><p class="text-idt25" data-id="302">255</p><p class="text-idt25" data-id="303">权限列表</p><p class="text-idt25" data-id="304">文章表</p><p class="text-idt25" data-id="305">字段名称</p><p class="text-idt25" data-id="306">数据类型</p><p class="text-idt25" data-id="307">字段长度</p><p class="text-idt25" data-id="308">说明</p><p class="text-idt25" data-id="309">id</p><p class="text-idt25" data-id="310">int</p><p class="text-idt25" data-id="311">5</p><p class="text-idt25" data-id="312">文章ID(主键)</p><p class="text-idt25" data-id="313">type</p><p class="text-idt25" data-id="314">int</p><p class="text-idt25" data-id="315">20</p><p class="text-idt25" data-id="316">文章类型</p><p class="text-idt25" data-id="317">title</p><p class="text-idt25" data-id="318">varchar</p><p class="text-idt25" data-id="319">20</p><p class="text-idt25" data-id="320">文章标题</p><p class="text-idt25" data-id="321">content</p><p class="text-idt25" data-id="322">mediumtext</p><p class="text-idt25" data-id="323">255</p><p class="text-idt25" data-id="324">文章内容</p><p class="text-idt25" data-id="325">author_id</p><p class="text-idt25" data-id="326">int</p><p class="text-idt25" data-id="327">5</p><p class="text-idt25" data-id="328">文章作者id</p><p class="text-idt25" data-id="329">status</p><p class="text-idt25" data-id="330">tinyint</p><p class="text-idt25" data-id="331">1</p><p class="text-idt25" data-id="332">文章状态</p><p class="text-idt25" data-id="333">views</p><p class="text-idt25" data-id="334">int</p><p class="text-idt25" data-id="335">20</p><p class="text-idt25" data-id="336">文章浏览量</p><p class="text-idt25" data-id="337">Comments</p><p class="text-idt25" data-id="338">int</p><p class="text-idt25" data-id="339">20</p><p class="text-idt25" data-id="340">文章评论数</p><p class="text-idt25" data-id="341">createtime</p><p class="text-idt25" data-id="342">int</p><p class="text-idt25" data-id="343">20</p><p class="text-idt25" data-id="344">文章创建时间</p><p class="text-idt25" data-id="345">updatetime</p><p class="text-idt25" data-id="346">int</p><p class="text-idt25" data-id="347">20</p><p class="text-idt25" data-id="348">文章更新时间</p><p class="text-idt25" data-id="349">dest</p><p class="text-idt25" data-id="350">varchar</p><p class="text-idt25" data-id="351">100</p><p class="text-idt25" data-id="352">对文章的简要描述</p><p class="text-idt25" data-id="353">文章分类表</p><p class="text-idt25" data-id="354">字段名称</p><p class="text-idt25" data-id="355">数据类型</p><p class="text-idt25" data-id="356">字段长度</p><p class="text-idt25" data-id="357">说明</p><p class="text-idt25" data-id="358">id</p><p class="text-idt25" data-id="359">int</p><p class="text-idt25" data-id="360">5</p><p class="text-idt25" data-id="361">角色ID(主键)</p><p class="text-idt25" data-id="362">name</p><p class="text-idt25" data-id="363">varchar</p><p class="text-idt25" data-id="364">20</p><p class="text-idt25" data-id="365">角色名称</p><p class="text-idt25" data-id="366">dest</p><p class="text-idt25" data-id="367">varchar</p><p class="text-idt25" data-id="368">20</p><p class="text-idt25" data-id="369">角色描述</p><p class="text-idt25" data-id="370">permission_list</p><p class="text-idt25" data-id="371">varchar</p><p class="text-idt25" data-id="372">255</p><p class="text-idt25" data-id="373">权限列表</p><p class="text-idt25" data-id="374">各个表之间的关系如下图：</p><p class="text-idt25" data-id="375">数据库模型</p><p class="text-idt25" data-id="376">接口</p><p class="text-idt25" data-id="377">http://www.shirdon.com/?p=426 参考网址</p><p class="text-idt25" data-id="378">系统实现</p><p class="text-idt25" data-id="379">文献：</p><p class="text-idt25" data-id="380">[1]李宇.前后端分离框架在软件设计中的应用[J].无线互联科技.2018，15(17):41-42.</p><p class="text-idt25" data-id="381">[2]汪彤.基于Node.js的图书共享平台的设计与实现[D].北京邮电大学.2018.</p><p class="text-idt25" data-id="382">[3]梁灏.Vue.js实战[M].清华大学出版社.2017.</p><p class="text-idt25" data-id="383">[4]麦冬.轻量级响应式框架Vue.js应用分析[J].信息与电脑(理论版).2017，(7):58-59.</p><p class="text-idt25" data-id="384">[5]刘红卫.利用Node.js开发前后端分离的系统——以图书馆地方文献系统为例[J].天津科技.2018，45(7):67-70.</p><p class="text-idt25" data-id="385">[6]茆玉庭.基于Node.js和WebSocket的即时通信系统的设计与实现[D].南京邮电大学.2018.</p><p class="text-idt25" data-id="386">[7]程桂花，沈炜，何松林，张珂杰.Node.js中Express框架路由机制的研究[J].工业控制计算机.2016，29(8):101-102.</p><p class="text-idt25" data-id="387">[8]王伶俐，张传国.基于NodeJS+Express框架的轻应用定制平台的设计与实现[J].计算机科学.2017，44(z2):596-599.</p><p class="text-idt25" data-id="388">[9]聂鑫.前端编程与数据库设计的合理运用[J].信息与电脑(理论版).2011，(2):100.</p><p class="text-idt25" data-id="389">[10]陈帅，关玉蓉.基于Java Web的奖助学金系统设计与实现[J].科技广场.2017，(3):190-192.</p><p class="text-idt25" data-id="390">[11]李玉.Vue框架的前端交互性能优化解决方案的研究[D].华中科技大学.2017</p><p class="text-idt25" data-id="391">[12]邹竞莹.Node.JS博客系统的设计与实现[D].黑龙江大学.2016.</p><p class="text-idt25" data-id="392">[13]旷志光，纪婷婷，吴小丽.基于Vue.js的后台单页应用管理系统的研究与实现[J].现代计算机.2017，(30):51-55.</p><p class="text-idt25" data-id="393">[14]邓雯婷.基于Vue.js构建单页面GIS应用的方法研究[J].科技创新与应用.2018，（14）：5-7，10.</p><p class="text-idt25" data-id="394">[15]朱二华.基于Vue.js的Web前端应用研究[J].科技与创新.2017，(20):119-121.</p><p class="text-idt25" data-id="395">[16]王志任.基于Vue.js的开发平台的设计与实现[D].广东工业大学.2018.</p>        <div class="paper-footer">
            <p>检测报告由<a href="http://www.paperpass.com/" target="_black">PaperPass</a>文献相似度检测系统生成</p>
            <p>Copyright © 2007-2019 PaperPass</p>
        </div>
    </div>

</div>
</body>
</html>

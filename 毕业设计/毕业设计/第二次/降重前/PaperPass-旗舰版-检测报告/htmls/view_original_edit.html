<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="keywords" content="">
    <meta name="description" content="">
    <title>修改文档</title>
    <link href="css/bootstrap.css" rel="stylesheet" />
    <link href="css/style.css" rel="stylesheet" />
</head>
<body>
<div class="bg-grey PLR40">

    <div class="paper-txt P30 PB0">
        <div class="alert alert-success" role="alert">此为您在“详细报告”中修改后临时保存的内容，编辑过的内容会变绿色</div>
        <p class="text-idt25" data-id="1">基于vue的个人博客的设计与实现</p><p class="text-idt25" data-id="2">姓名：周会艳</p><p class="text-idt25" data-id="3">院系：信息工程学院</p><p class="text-idt25" data-id="4">专业：计算机科学与技术</p><p class="text-idt25" data-id="5">导师：郑颖</p><p class="text-idt25" data-id="6">完成时间：2019-00-00</p><p class="text-idt25" data-id="7">基于vue的个人博客的设计与实现</p><p class="text-idt25" data-id="8">摘要：</p><p class="text-idt25" data-id="9">互联网成为了当今世界人们对外交流，快速获取、发布和传递信息的最常用也是最便捷的渠道，互联网技术在人们生活、工作与学习的方方面面都发挥着重要的作用。而博客网站正适应这种人际与技术交流方式的改变，满足个人技术与信息共享的需求。本文对博客的功能与需求进行了完整分析，设计出了一个简单、易用的个人博客系统。为了提高开发效率和代码复用率，本系统使用采用SPA（单页面应用）思想的vue.js进行系统的开发。Vue.js是一个轻量级的基于MVVM模式的渐进式框架。vue的组件化与数据绑定的思想，在很大程度上简化了前端开发的复杂度。后端将node.js技术与express结合使用，以创建符合RESTful API设计规范的接口</p><p class="text-idt25" data-id="10">关键词 博客，vue.js ，node.js ，API，vuex</p><p class="text-idt25" data-id="11">Design and implementation of personal blog based on vue</p><p class="text-idt25" data-id="12">Abstract：The Internet has become the most common and convenient channel for people to communicate with others in today’s world. Internet technology plays an important role in all aspects of people’s life， work and study. Blog sites are adapting to this change in interpersonal and technical communication， to meet the needs of personal technology and information sharing. This article has carried on the complete analysis to the blog function and the demand， has designed a simple， easy to use personal blog system. In order to improve the development efficiency and code reuse rate， the system USES the idea of SPA (single page application) for the development of vue. Js system. Vue. Js is a lightweight progressive framework based on the MVVM pattern. The idea of vue componentization and data binding greatly simplifies the complexity of front-end development. The back end USES node.js technology in conjunction with express to create interfaces that conform to RESTful API design specifications.</p><p class="text-idt25" data-id="13">keywords:blog，vue.js ，node.js ，API，vuex</p><p class="text-idt25" data-id="14">绪论6</p><p class="text-idt25" data-id="15">1.1博客的背景6</p><p class="text-idt25" data-id="16">1.2系统设计的意义6</p><p class="text-idt25" data-id="17">系统相关技术介绍6</p><p class="text-idt25" data-id="18">SPA（Single Page App）6</p><p class="text-idt25" data-id="19">单页应用6</p><p class="text-idt25" data-id="20">与传统网页的比较7</p><p class="text-idt25" data-id="21">单页应用的好与坏8</p><p class="text-idt25" data-id="22">NPM9</p><p class="text-idt25" data-id="23">2.1vue.js9</p><p class="text-idt25" data-id="24">2.1.1介绍9</p><p class="text-idt25" data-id="25">2.2.1 组件化应用构建10</p><p class="text-idt25" data-id="26">2.2.2 vue响应式原理11</p><p class="text-idt25" data-id="27">2.2.5 与其他框架相比优点12</p><p class="text-idt25" data-id="28">Vue-cli12</p><p class="text-idt25" data-id="29">2.3状态管理13</p><p class="text-idt25" data-id="30">2.4node.js14</p><p class="text-idt25" data-id="31">4.1.1简介14</p><p class="text-idt25" data-id="32">2.4.1Node.js模块系统15</p><p class="text-idt25" data-id="33">Node.js Express 框架16</p><p class="text-idt25" data-id="34">2.4Node.js GET/POST请求17</p><p class="text-idt25" data-id="35">2.3Node.js的RESTful API18</p><p class="text-idt25" data-id="36">2.4Node.js 连接 MySQL18</p><p class="text-idt25" data-id="37">系统分析19</p><p class="text-idt25" data-id="38">3.1需求分析19</p><p class="text-idt25" data-id="39">3.23.2 可行性分析19</p><p class="text-idt25" data-id="40">系统设计20</p><p class="text-idt25" data-id="41">前台功能设计20</p><p class="text-idt25" data-id="42">后台功能设计20</p><p class="text-idt25" data-id="43">数据库设计21</p><p class="text-idt25" data-id="44">概念结构设计21</p><p class="text-idt25" data-id="45">逻辑结构设计22</p><p class="text-idt25" data-id="46">系统实现23</p><p class="text-idt25" data-id="47">注册功能的实现23</p><p class="text-idt25" data-id="48">登录功能的具体实现24</p><p class="text-idt25" data-id="49">前台文章列表的实现25</p><p class="text-idt25" data-id="50">后台管理系统的实现25</p><p class="text-idt25" data-id="51">组件及路由设计25</p><p class="text-idt25" data-id="52">axios封装26</p><p class="text-idt25" data-id="53">登录拦截27</p><p class="text-idt25" data-id="54">绪论</p><p class="text-idt25" data-id="55">1.1博客的背景</p><p class="text-idt25" data-id="56"> Blog是继 Email， BBS和 ICQ之后出现的第四种网络沟通方式，它是互联网时代的个人“读者文摘”，更代表着新的生活方式、新的工作方式和新的学习方式。简言之， Blog就是以网络作为载体，简易迅速便捷地发布自己的心得，及时有效轻松地与他人进行交流，是一个丰富多彩的展示个性化的综合性平台.;</p><p class="text-idt25" data-id="57">博客的分类有很多。比如，按功能分：基本博客、微型博客；按用户分：个人博客、企业博客；按存在方式分：附属博客，托管博客，独立博客。本系统就是按用户划分的个人博客。</p><p class="text-idt25" data-id="58">博客有以下特点：</p><p class="text-idt25" data-id="59">简单的操作是博客开发的动力。这是博客受到如此众多网友欢迎的最大特点。许多博客托管网站使用的口号就是“在一分钟内轻松拥有一个博客”。</p><p class="text-idt25" data-id="60">2、不断更新是博客壮大的催化剂。现代社会，信息传递的速度非常快速，博客的更新就如逆水行舟，在时代的洪流中没有原地不动，只用前进与退步，不及时更新的博客很快就会被淹没在技术前进的道路上。</p><p class="text-idt25" data-id="61">3、开放互动是博客传播的推动剂。互联网赋予了博客开放性的特点，那么博客也就不在再是一个单纯的私人空间。访问者和其他博主给我们的文章撰写留言或评论，如果我们回复，并通过链接地址对他们回访，则可以实现互动效果。因此，只要善于利用博客开放互动的特点，就可以将博客用于交流和推广，使之最终形成一个固定的圈子.;</p><p class="text-idt25" data-id="62">4、展示个性是博客出彩的原动力。作为博主可以在博客的界面设计，功能搭配与文章喜好上展现出自己的独有的个人性格特点，吸引同类或者欣赏此类性格的访问者。</p><p class="text-idt25" data-id="63">1.2系统设计的意义</p><p class="text-idt25" data-id="64">在科技快速进步的今天，互联网成为了当今世界人们对外交流，快速获取、发布和传递信息的最常用也是最便捷的渠道，互联网在人们的日常生活中发挥着举足轻重的作用。当今时代，技术日新月异，作为互联网技术从业者，需要不断的汲取新知识，走在技术的前沿，但是大部分新技术文档与书籍都是英文，对于英语能力有限的互联网技术从业者，不可避免的需要借助搜素引擎或者其他人的帮助，在搜索引擎的搜索结果中大部分的技术问题解决方案的贡献者都来自博客，所以此次毕业设计自己也想要做一个记录自己学习与工作过程的心得体会的博客网站，去适应这种人际与技术交流方式的改变，同时也实现个人技术与信息共享的需求。</p><p class="text-idt25" data-id="65">系统相关技术介绍</p><p class="text-idt25" data-id="66">SPA（Single Page App）</p><p class="text-idt25" data-id="67">单页应用</p><p class="text-idt25" data-id="68">单页应用（英语：Single Page Application， SPA）是通过动态重写当前页面与用户交互的Web应用程序或网站的模型。避免了传统网页模型的打断用户体验的页面切换方式，也避免了不断的加载整个新页面，减轻了服务器的负担。在单页应用中，通过加载单个页面来检索所有必需的代码（HTML，JavaScript和CSS）。 或者根据需要动态加载适当的资源并通过路由程序将它们添加到页面中（通常是响应用户操作）。网站所有的页面内容都包含在这个主页面中。但是在实际开发的时候，还是会分开写（页面片段）。SPA支持丰富的客户端功能，很少需要重新加载整个页面，因此当用户执行操作或在应用的各个区域之间导航时，无需重新加载整个页面。因此，它的加载速度更快，在后台提取数据，对单个用户操作的响应更快。</p><p class="text-idt25" data-id="69">与传统网页的比较</p><p class="text-idt25" data-id="70">为了更好的理解什么是单页应用，我们先来了解传统的网页应用。传统网页应用的工作模式如下图</p><p class="text-idt25" data-id="71">/</p><p class="text-idt25" data-id="72">传统网页应用的工作模式</p><p class="text-idt25" data-id="73">此种方式作为网页应用的传统形式长久不衰，很多流行的开发框架都以之作为范式设计的。比如 Ruby on Rails，Spring MVC，Express 等等</p><p class="text-idt25" data-id="74">/</p><p class="text-idt25" data-id="75">传统网页应用的工作分布</p><p class="text-idt25" data-id="76">在传统的WEB应用中，浏览器作为展示层view，mode与controller等更多计算与调度的例如路由跳转，数据请求等都是由服务器端进行的。</p><p class="text-idt25" data-id="77">在传统的网页应用中，浏览器更多的是充当一个展示层，路由处理、服务调用、页面跳转流程都由服务端来处理。即 MVC 都放在服务器端，而 V 作为用户界面则通过网络发送到浏览器端，作为 UI 与用户交互。</p><p class="text-idt25" data-id="78">这样的范式有以下特点：</p><p class="text-idt25" data-id="79">服务端负担过重，由于 MVC存在于服务器上，因此开发资源的重点和此类应用程序的开发偏向于后端，并且后端工程师通常会领导整个项目的开发;</p><p class="text-idt25" data-id="80">页面经常刷新，当页面的功能发生变化时，页面就需要进行刷新，导致资源的浪费。而且导致用户需要花费额外的时间等待页面刷新，用户体验不佳。</p><p class="text-idt25" data-id="81">相较于传统网页应用，单页应用将 MVC 前置到了浏览器端：</p><p class="text-idt25" data-id="82">/</p><p class="text-idt25" data-id="83">单页应用的工作分布</p><p class="text-idt25" data-id="84">1控制器前置，单页应用将对页面路由的处理放在浏览器端，即直接响应浏览器端的浏览地址的变化，将变化通知到与之对应的路由，以此来向用户呈现对应的界面。</p><p class="text-idt25" data-id="85">2小组件为功能元件。单页应用以小的组件作为功能元件，在路由变化时，不再刷新整个页面，而是将这些小组件进行组合以实现页面的改变。</p><p class="text-idt25" data-id="86">3数据层前置。使用JSON发送应用数据的方式，会在HTML的视图层和应用程序层之间创建一种分离。这便使得表示层与应用层相分离，浏览器端形成一层实实在在的数据层，而服务端则退化成了完全的数据 API，以方便不同的开发人员去独立地开发每一个层面。</p><p class="text-idt25" data-id="87">单页应用的好与坏</p><p class="text-idt25" data-id="88">每一种技术都有优缺点，单页应用也不例外。单页面开发的优点：</p><p class="text-idt25" data-id="89">1良好的用户体验：用户无需刷新页面，减少HTTP的请求造成的时间损耗，获取数据也是通过Ajax异步获取。</p><p class="text-idt25" data-id="90">2前后端分离：前端负责界面显示，后端负责数据存储和计算，使得前后端的业务与数据逻辑更加清晰明了。</p><p class="text-idt25" data-id="91">3减轻服务端压力：在单叶应用中服务器只需要提供数据的 API接口，不需要知道前端的代码实现，服务器不再负责页面逻辑和页面拼接，可以将服务器的性能使用到极致。</p><p class="text-idt25" data-id="92">4共享一组后端程序代码：同一组后端程序代码，可以在不经修改的情况下就可以适用于三端Web、手机、平板。</p><p class="text-idt25" data-id="93">5组件共享：对于使用到同样功能或者同样展示型组件的多端应用可以在项目中开辟公共组件的存储文件，将所有的公共组件都放入其中，以供多端使用，简化了代码的重复性。</p><p class="text-idt25" data-id="94">单页面开发的缺点：</p><p class="text-idt25" data-id="95">1首屏加载过慢：当第一次加载单页面时，需要组合所有页面所依赖的css和js 并统一加载它们。所以css和js文件会较大，会在一定程度上影响页面加载时间。</p><p class="text-idt25" data-id="96">2 SEO：由于页面数据都是前端异步加载出来的，浏览器看到的是所有结构加载出来之前的页面，找不到meat标签或者任何可用的文字，不利于搜索引擎的抓取。</p><p class="text-idt25" data-id="97">如果应用要求包括超出了典型 HTML 所能提供的丰富的功能，则应选择 SPA 样式应用程序。</p><p class="text-idt25" data-id="98">NPM</p><p class="text-idt25" data-id="99">由于使用到的技术都是通过npm来安装的，所以先来介绍npm到底是什么：</p><p class="text-idt25" data-id="100">为什么我们需要一个包管理工具呢? 因为我们在Node. js上开发时， 会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生:大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。</p><p class="text-idt25" data-id="101">更重要的是，如果我们要使用模块 A，而模块 A又依赖于模块 B，而模块 C和模块 D又是模块 B的依赖， npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p><p class="text-idt25" data-id="102">NPM 即 Node 包管理器（Node Package Manager）。它是一个以 Node.js为默认环境 ，使用JavaScript 编写的软件包管理系统。在 Node.js 0.6.3 版本之前npm需要自行安装，但是node.js 0.6.3之后NPM 被自动附带在安装包中。</p><p class="text-idt25" data-id="103">使用npm安装包的命令是：npm install 包名 [--save-dev]</p><p class="text-idt25" data-id="104">--save与-dev都是可选的，--save表示自动修改package.js文件，并自动添加依赖项。</p><p class="text-idt25" data-id="105">--save:将安装的包放在依赖项dependencies中</p><p class="text-idt25" data-id="106">--save-dev:安装的包将出现在devDependencies中</p><p class="text-idt25" data-id="107">2.1vue.js</p><p class="text-idt25" data-id="108">2.1.1介绍</p><p class="text-idt25" data-id="109">Vue.js是尤玉溪编写的用来构建用户界面的渐进式 JavaScript 框架 。与其它大型框架不同的是，Vue 被设计为可以自下而上应用。Vue.js的核心库只关注视图层，使其不仅易于上手，而且还便于与第三方库或现有项目整合。另一方面，当与现代化工具链和各种支持类库结合使用时，Vue.js 也完全能够为复杂的单页应用提供驱动。</p><p class="text-idt25" data-id="110">/</p><p class="text-idt25" data-id="111">Vue.js中View与Model的交互原理</p><p class="text-idt25" data-id="112">此图不仅描述了MVVM模式（Model-View_ViewModel），还描述了在Vue.js中ViewModel是如何和View以及Model进行交互的。</p><p class="text-idt25" data-id="113">ViewModel是Vue.js的核心，它是一个Vue实例。Vue的实例是绑定在HTML的元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。</p><p class="text-idt25" data-id="114">当创建了ViewModel后，双向绑定是如何达成的呢？</p><p class="text-idt25" data-id="115">DOM Listener和Data Bindings这两个工具是实现双向绑定的关键。</p><p class="text-idt25" data-id="116">在View侧也就是页面上，DOM Listeners工具会监测页面上DOM结构与元素的变化，一旦发生变化，就会去更改Model中的数据。</p><p class="text-idt25" data-id="117">在 Model侧也就是传统意义上的服务器端上，当我们将 Model中的数据进行更新时， Data Bindings工具会将数据变化同时到页面，从而更新页面中的 DOM元素。</p><p class="text-idt25" data-id="118">2.2.1 组件化应用构建</p><p class="text-idt25" data-id="119">组件系统是 Vue 的重要概念，它是一种抽象的概念，此设计允许我们使用小型的、独立的和通常可复用的组件通过组合去构建大型应用。在WEB网页制作中几乎任意类型的应用界面都可以抽象为一个组件树：</p><p class="text-idt25" data-id="120">/</p><p class="text-idt25" data-id="121">页面结构的树形示意</p><p class="text-idt25" data-id="122">2.2.2 vue响应式原理</p><p class="text-idt25" data-id="123">Vue 最独特的功能之一是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单直接。Vue 响应式系统的底层的细节如下图：</p><p class="text-idt25" data-id="124">/</p><p class="text-idt25" data-id="125">vue响应式原理</p><p class="text-idt25" data-id="126">vue如何追踪变化呢？将普通的 JavaScript 对象传给 Vue 实例的 data 选项时，Vue 将迭代此对象所有的属性，并使用 Object.defineProperty 将所有这些属性转为 getter/setter。由于Object.defineProperty 在ES5中是一个无法 shim 的特性导致Vue.js不支持 IE8 及以下低版本的浏览器。这些 getter/setter 对用户是不可见的，但是内部 Vue 通过它们跟踪依赖关系，在属性被访问和修改时通知变化。每个组件实例都有一个相应的 watcher实例对象，该对象在组件呈现的过程将该属性记录为依赖项。稍后，当调用依赖项的 setter时，会通知 watcher重新计算，从而更新其关联的组件。这就是vue响应式更新组件的原理。</p><p class="text-idt25" data-id="127">2.2.5 与其他框架相比优点</p><p class="text-idt25" data-id="128">1易用。只需要已学习了HTML、CSS、JavaScript，就可以阅读vue开发指南并开始构建应用程序。不像其他前端框架一样有比较高的使用门槛。</p><p class="text-idt25" data-id="129">2.灵活。一个繁荣的生态系统，可以在库和完整的框架之间进行自行扩。</p><p class="text-idt25" data-id="130">Vue-cli</p><p class="text-idt25" data-id="131"> Vue- cli是 vue官方开发的脚手架工具，基于 webpack构建，很好地规范了其开发生态，开发者只需要关注业务代码本身，而不必操心复杂的 webpack配置，可以说是对开发人员尤其是新手是相当友好的。</p><p class="text-idt25" data-id="132">Vue CLI 提供了以下功能：</p><p class="text-idt25" data-id="133">1通过 @vue/cli 搭建交互式的项目脚手架。</p><p class="text-idt25" data-id="134">2通过 @vue/cli + @vue/cli-service-global 快速开始零配置原型开发。</p><p class="text-idt25" data-id="135">3一个运行时依赖 (@vue/cli-service)，该依赖：</p><p class="text-idt25" data-id="136">1.可升级；</p><p class="text-idt25" data-id="137">2基于 webpack 构建，并带有合理的默认配置；</p><p class="text-idt25" data-id="138">3可以通过项目内存在的配置文件进行自主配置；</p><p class="text-idt25" data-id="139">4可以通过插件进行扩展。</p><p class="text-idt25" data-id="140">5丰富的官方插件集，集成了前端生态中的最佳工具。</p><p class="text-idt25" data-id="141">6用于创建和管理 Vue.js 项目的完全图形用户界面。</p><p class="text-idt25" data-id="142">上边提到了webpack，那么什么是webpack呢？请看以下介绍：</p><p class="text-idt25" data-id="143"> webpack就是前端资源模块化管理和打包工具，它可以将很多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源，还可以将按需加载的模块进行代码分割，等到实际需要的时候再异步加载（如图），而要它自动实现这些功能，你得提前编辑好配置文件。/</p><p class="text-idt25" data-id="144">用vue项目来举例：浏览器它是只认识js，不认识vue的。我们编写的代码后缀主要是.vue的，而html、js、css甚至是图片资源可能是在每个.vue文件中；并且由于组件化，每一个.vue文件之间还有错综复杂的关系。所以项目要被浏览器识别，我们就要使用webpack将它们打包成js文件以及相应的资源文件。</p><p class="text-idt25" data-id="145">WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到 JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（ less， TypeScript等），并将其打包为合适的格式以供浏览器使用。</p><p class="text-idt25" data-id="146">2.3状态管理</p><p class="text-idt25" data-id="147">Vuex是一个专为Vue.js设计的状态管理库，可利用Vue.js的细粒度数据响应机制实现高效的状态更新。本系统使用vuex来进行系统组件之前公共数据的管理。 nbsp;</p><p class="text-idt25" data-id="148">Vuex是一种集中的状态管理模型。在vue的模块化开发过程中使用了组件作为模块单元。 这确保了我们模块之间的变量函数名称不会发生冲突，但有时我们需要在组件之间共享一些数据或状态，通常使用参数。但是传参的做法至少有两个弊端，一个是麻烦（特别是当需要传递很多参数时），其次，管理和冗余并不容易（将参数传递给多个组件需要多个参数列表。 而且容易出错)。 vuex提供的集中管理通过集中要共享的数据或状态来解决此问题。其他组件根据需要访问更改，大大提高了系统的可维护性和开发效率。</p><p class="text-idt25" data-id="149">/</p><p class="text-idt25" data-id="150">vuex状态管理流程</p><p class="text-idt25" data-id="151">所有 store 中 state 的改变，都放置在 store 自身的 action 中去管理。这种集中式状态管理能够被更容易地理解哪种类型的 mutation 将会发生，以及它们是如何被触发。当错误出现时，我们现在也会有一个 log 记录 bug 之前发生了什么。</p><p class="text-idt25" data-id="152">2.4node.js</p><p class="text-idt25" data-id="153">4.1.1简介</p><p class="text-idt25" data-id="154">Node. js是一个Javascript运行环境(runtime)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node， js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。</p><p class="text-idt25" data-id="155">V8引擎本身就是用于Chrome浏览器的JS解释部分但是Ryan Dahl 把这个V8搬到了服务器上，用于做服务器的软件。</p><p class="text-idt25" data-id="156">Node. js是一个专注于实现高性能Web服务器优化的专家，几经探索，几经挫折后，遇到V8而诞生的项目。</p><p class="text-idt25" data-id="157">Node. js是一个让JavaScript运行在服务器端的开发平台，它让JavaScript的触角伸到了服务器端，可以与PHP、JSP、Python、Ruby 平起平坐。</p><p class="text-idt25" data-id="158">但Node似乎有点不同:</p><p class="text-idt25" data-id="159">Node. js不是一种独立的语言，与PHP、JSP Python的“既是语言，也是平台“不同，Node. js使用JavaScript进行编程，运行在JavaScript引擎上(V8)。</p><p class="text-idt25" data-id="160">与PHP、JSP等相比(PHP、JSP、 . net都需要运行在服务器程序上，Apache、 Nag-inx、IIS. ) ， Node. js跳过了Apache、 Naginx、 IIS 等HTTP服务器，它自己不用建设在任何服务器软件之上。Node. js的许多设计理念与经典架构(LANP = Linux + Apache+ MySQL + PHP)有着很大的不同，可以提供强大的伸缩能力。一会儿我们就将看到，Node. js没有web容器。</p><p class="text-idt25" data-id="161">Node. js自身哲学，是花最小的硬件成本，追求更高的并发，更高的处理性能。</p><p class="text-idt25" data-id="162">官网: https://nodejs. org en/</p><p class="text-idt25" data-id="163">特点: Node. js uses an event- driven， non- blocking I/0 model that makes itlightweight and efficient.( node. js使用事件驱动的非阻塞 I/0模型，使其轻量级和高效).</p><p class="text-idt25" data-id="164">2.4.1Node.js模块系统</p><p class="text-idt25" data-id="165">什么是模块?</p><p class="text-idt25" data-id="166">Node.js中，将很多的功能，划分成了一个个的module，有些书将其翻译为模块，有些书将其翻译为模组。由于每一个程序的功能不一样，用到的所以为了效率，需要什么模块就require什么模块。</p><p class="text-idt25" data-id="167">模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。每个模块都有自己的作用域，当我们使用 var 来申明的一个变量，他并不是全局的，而是属于当前模块下。</p><p class="text-idt25" data-id="168">模块是构建应用程序的基础，也使得函数和变量私有化，不直接对外暴露出来，接下来我们就要介绍Node的模块化系统和它最常用的模式。JavaScript起初并没有内置的模块系统，CommonJS社区为了使JavaScript可以提供一个类似Python、Ruby等的标准库，自己实现了一套API填补了JavaScript没有内置模块的空白。</p><p class="text-idt25" data-id="169"> CommonJS规范本身涵盖了模块、二进制、 Buffer、文件系统、包管理等内容，而 NodeJS正是借鉴了 CommonJS规范的模块系统，自身实现了一套非常易用的模块系统。CommonJS对模块的定义可分为三部分：模块引用（require）、模块定义（exports、module）、模块标识。</p><p class="text-idt25" data-id="170">在Node.js中，以模块为单位划分所有功能，并且提供了一个完整的模块加载机制，这时的我们可以将应用程序划分为各个不同的部分。我们不可能用一个js文件去写全部的业务。肯定要有WVC.</p><p class="text-idt25" data-id="171">狭义的说，每一个JavaScript文件都是一个模块:而多个JavaScript文件之间可以相互require，他们共同实现了一个功能，他们整体对外，又称为一个广义上的模块。</p><p class="text-idt25" data-id="172">Node. js中，一个JavaScript文件中定义的变量函数，都只在这个文件内部有效。当需要从此JS文件外部引用这些变量、函数时，必须使用oxports对象进行举露。使用者要用require0命令引用这个JS文件。例子如下：</p><p class="text-idt25" data-id="173">在Node.js 中创建模块</p><p class="text-idt25" data-id="174">/</p><p class="text-idt25" data-id="175">当我们需要在其他地方使用 config.js方法时，比如：</p><p class="text-idt25" data-id="176">/</p><p class="text-idt25" data-id="177">我们只需要调用 require(’./config) 就能实现对模块的引入。</p><p class="text-idt25" data-id="178">Node.js Express 框架</p><p class="text-idt25" data-id="179">Express 是一个简洁而灵活的 node.js Web应用框架， 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。使用 Express 可以快速地搭建一个完整功能的网站。Express框架是后台的Node框架，所以和jQuery、element-ui、bootstrap都不是一个东西。</p><p class="text-idt25" data-id="180"> Express和 js框架或者后台框架一样，把我们经常使用的东西比如方法放到一起，就形成了自己的一套东西，其实就是一个完善的库文件，里面写了大量的函数。Express的思想是在于在工程师的想法和服务器之间充当很薄的一层。这并不意味着Express不够健壮，或者没有足够的有用的特性，而是尽量少干预你，让你充分表达自己的思想，同时提供一些有用的东西。Express 框架核心特性如下：</p><p class="text-idt25" data-id="181">1强大的路由能力</p><p class="text-idt25" data-id="182">2强大的静态文件渲染能力。</p><p class="text-idt25" data-id="183">3对模版引擎支持。可以通过向模板传递参数来动态渲染 HTML 页面。</p><p class="text-idt25" data-id="184">4丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单</p><p class="text-idt25" data-id="185">5 性能更好。Express 在node.js 上扩展了Web应用所需的功能</p><p class="text-idt25" data-id="186">安装 Express 并将其保存到依赖列表中：</p><p class="text-idt25" data-id="187">$ npm install express --save</p><p class="text-idt25" data-id="188">2.4Node.js GET/POST请求</p><p class="text-idt25" data-id="189">GET的请求方式实际就是通过地址栏参数的形式发送请求的，下面是GET获取地址栏参数的方法：</p><p class="text-idt25" data-id="190">/</p><p class="text-idt25" data-id="191">获取get参数</p><p class="text-idt25" data-id="192">POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。比如文件的上传，但是大多时候我们并不需要理会请求体的内容，因为恶意的 POST请求会大大消耗服务器的资源，所以 node. js默认不解析请求体的，所以当需要解析 post请求体时，需要自己来进行参数的解析工作。</p><p class="text-idt25" data-id="193">/</p><p class="text-idt25" data-id="194">获取post请求</p><p class="text-idt25" data-id="195">2.3Node.js的RESTful API</p><p class="text-idt25" data-id="196">REST全称是Representational State Transfer，中文意思是表述（编者注： 通常译为表征）性状态转移。它首次出现在2000年Roy Fielding的博士论文中，而Roy Fielding是HTTP规范的主要作者之一。 他在论文中提到： “我写作的目的是理解和评估基于网络的应用程序的架构设计，符合架构原则。 获得功能强大，良好且适合通信的结构。 REST指的是一组架构约束条件和原则。 如果架构符合REST约束和原则，我们称之为RESTful架构。</p><p class="text-idt25" data-id="197"> REST本身并没有创造新的技术、组件或服务，而隐藏在 RESTful背后的理念就是使用 Web的现有特征和能力，更好地使用现有 Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以我们这里描述的REST也是通过HTTP实现的REST。</p><p class="text-idt25" data-id="198">2.4Node.js 连接 MySQL</p><p class="text-idt25" data-id="199">连接数据库代码如图所示，其中connect()方法用来创建连接，end()方法用来关闭连接，query()方法用来向mysql传递参数。</p><p class="text-idt25" data-id="200">/</p><p class="text-idt25" data-id="201">连接mysql数据库</p><p class="text-idt25" data-id="202">系统分析</p><p class="text-idt25" data-id="203">3.1需求分析</p><p class="text-idt25" data-id="204">想要完成一个系统，需求分析是第一步，明确系统是什么，要干什么，完成那些功能。</p><p class="text-idt25" data-id="205">本系统需求如下：</p><p class="text-idt25" data-id="206">博客的游客用户可以在网站上对文章进行常规访问。以及在通过注册登录后，可以进行文章的发布与发表评论。博主可以通过后台对用户进行管理以及文章与文章分类添加、删除、修改。</p><p class="text-idt25" data-id="207">针对博客系统的以上需求，总结出如下信息：</p><p class="text-idt25" data-id="208">1.用户分为游客、普通用户和超级管理用户。</p><p class="text-idt25" data-id="209">2.超级管理用户员可以用户进行管理和设置权限。</p><p class="text-idt25" data-id="210">3.博客的超级管理员涉及对博客的文章类型管理、文章管理、评论管理、和用户管理。</p><p class="text-idt25" data-id="211">4.用户可以阅读文章、发表评论，游客只能进行文章的阅读。</p><p class="text-idt25" data-id="212">5.文章类型与文章之间形成一对多的关系，文章与评论之间也是一对多的关系。</p><p class="text-idt25" data-id="213">3.23.2 可行性分析</p><p class="text-idt25" data-id="214">可行性分析( Feasibility Analysis)是在系统调查的基础上，针对新系统的开发是否具备必要性和可能性，对新系统的开发从技术、经济、社会的方面进行分析和研究，以避免投资失误，保证新系统的开发成功。可行性研究的目的就是用最小的代价在尽可能短的时间内确定问题是否能够解决。为了确定开发具有可行性，对本系统主要进行了以下几个方面的分析。</p><p class="text-idt25" data-id="215">技术可行性分析：本人对于VUE.JS与NODE.JS在实习中有所接触，对这方面有所了解，所以从技术方面看做个人博客是可行的。</p><p class="text-idt25" data-id="216">时间可行性：现在博客技术已经非常成熟，多方面的问题都有成熟的解决方案，结合技术可行性，在预定的时间里可以完成此次设计。</p><p class="text-idt25" data-id="217">系统设计</p><p class="text-idt25" data-id="218">个人博客的总体规划图如下：</p><p class="text-idt25" data-id="219">/</p><p class="text-idt25" data-id="220">前台功能设计</p><p class="text-idt25" data-id="221">在前台，游客浏览首页，文章详情页，文章列表与文章分类，注册用户在此基础上可以对文章进行评论。</p><p class="text-idt25" data-id="222">/</p><p class="text-idt25" data-id="223">后台功能设计</p><p class="text-idt25" data-id="224">超级管理员通过预设的账号登录后台。超级管理员可以在后台对文章进行增删查改，对文章分类进行增删查改，对评论进行查看和删除；对注册用户进行管理，可以进行的操作有查看和封禁。</p><p class="text-idt25" data-id="225">数据库设计</p><p class="text-idt25" data-id="226">数据库设计</p><p class="text-idt25" data-id="227">数据库是个人博客设计的主要部分，本系统选用了mysql数据库，使用navicat premium可</p><p class="text-idt25" data-id="228">视化数据库管理工具进行数据库的设计与管理。</p><p class="text-idt25" data-id="229">概念结构设计</p><p class="text-idt25" data-id="230">对于属性比较多的实体，在E_R图中只列出了部分属性以做示意，具体的详细设计将体现在数据库表的结构中。如下图所以：/</p><p class="text-idt25" data-id="231">数据库概念结构e-r图</p><p class="text-idt25" data-id="232">逻辑结构设计</p><p class="text-idt25" data-id="233">从实际需求出发以数据库的概念结构设计为基础，设计出如下表结构</p><p class="text-idt25" data-id="234">（1）用户表管理用户的信息。表结构设计如下：</p><p class="text-idt25" data-id="235">字段名称</p><p class="text-idt25" data-id="236">数据类型</p><p class="text-idt25" data-id="237">字段长度</p><p class="text-idt25" data-id="238">说明</p><p class="text-idt25" data-id="239">id</p><p class="text-idt25" data-id="240">int</p><p class="text-idt25" data-id="241">5</p><p class="text-idt25" data-id="242">用户ID(主键)</p><p class="text-idt25" data-id="243">account</p><p class="text-idt25" data-id="244">varchar</p><p class="text-idt25" data-id="245">50</p><p class="text-idt25" data-id="246">登录名</p><p class="text-idt25" data-id="247">password</p><p class="text-idt25" data-id="248">varchar</p><p class="text-idt25" data-id="249">50</p><p class="text-idt25" data-id="250">密码</p><p class="text-idt25" data-id="251">pwd_salt</p><p class="text-idt25" data-id="252">int</p><p class="text-idt25" data-id="253">5</p><p class="text-idt25" data-id="254">密码加盐随机数</p><p class="text-idt25" data-id="255">nickname</p><p class="text-idt25" data-id="256">varchar</p><p class="text-idt25" data-id="257">50</p><p class="text-idt25" data-id="258">用户名字</p><p class="text-idt25" data-id="259">birthday</p><p class="text-idt25" data-id="260">date</p><p class="text-idt25" data-id="261">20</p><p class="text-idt25" data-id="262">出生日期</p><p class="text-idt25" data-id="263">gender</p><p class="text-idt25" data-id="264">tinyint</p><p class="text-idt25" data-id="265">1</p><p class="text-idt25" data-id="266">性别</p><p class="text-idt25" data-id="267">introduce</p><p class="text-idt25" data-id="268">varchar</p><p class="text-idt25" data-id="269">200</p><p class="text-idt25" data-id="270">个人介绍</p><p class="text-idt25" data-id="271">status</p><p class="text-idt25" data-id="272">tinyint</p><p class="text-idt25" data-id="273">1</p><p class="text-idt25" data-id="274">用户状态</p><p class="text-idt25" data-id="275">role_id</p><p class="text-idt25" data-id="276">int</p><p class="text-idt25" data-id="277">5</p><p class="text-idt25" data-id="278">角色id</p><p class="text-idt25" data-id="279">（2）角色表存储用户角色，表结构设计如下：</p><p class="text-idt25" data-id="280">字段名称</p><p class="text-idt25" data-id="281">数据类型</p><p class="text-idt25" data-id="282">字段长度</p><p class="text-idt25" data-id="283">说明</p><p class="text-idt25" data-id="284">id</p><p class="text-idt25" data-id="285">int</p><p class="text-idt25" data-id="286">5</p><p class="text-idt25" data-id="287">角色ID(主键)</p><p class="text-idt25" data-id="288">name</p><p class="text-idt25" data-id="289">varchar</p><p class="text-idt25" data-id="290">20</p><p class="text-idt25" data-id="291">角色名称</p><p class="text-idt25" data-id="292">dest</p><p class="text-idt25" data-id="293">varchar</p><p class="text-idt25" data-id="294">20</p><p class="text-idt25" data-id="295">角色描述</p><p class="text-idt25" data-id="296">permission_list</p><p class="text-idt25" data-id="297">varchar</p><p class="text-idt25" data-id="298">255</p><p class="text-idt25" data-id="299">权限列表</p><p class="text-idt25" data-id="300">（3）文章表管理博客发表的文章，表结构设计如下：</p><p class="text-idt25" data-id="301">字段名称</p><p class="text-idt25" data-id="302">数据类型</p><p class="text-idt25" data-id="303">字段长度</p><p class="text-idt25" data-id="304">说明</p><p class="text-idt25" data-id="305">id</p><p class="text-idt25" data-id="306">int</p><p class="text-idt25" data-id="307">5</p><p class="text-idt25" data-id="308">文章ID(主键)</p><p class="text-idt25" data-id="309">type</p><p class="text-idt25" data-id="310">int</p><p class="text-idt25" data-id="311">20</p><p class="text-idt25" data-id="312">文章类型</p><p class="text-idt25" data-id="313">title</p><p class="text-idt25" data-id="314">varchar</p><p class="text-idt25" data-id="315">20</p><p class="text-idt25" data-id="316">文章标题</p><p class="text-idt25" data-id="317">content</p><p class="text-idt25" data-id="318">mediumtext</p><p class="text-idt25" data-id="319">255</p><p class="text-idt25" data-id="320">文章内容</p><p class="text-idt25" data-id="321">author_id</p><p class="text-idt25" data-id="322">int</p><p class="text-idt25" data-id="323">5</p><p class="text-idt25" data-id="324">文章作者id</p><p class="text-idt25" data-id="325">status</p><p class="text-idt25" data-id="326">tinyint</p><p class="text-idt25" data-id="327">1</p><p class="text-idt25" data-id="328">文章状态</p><p class="text-idt25" data-id="329">views</p><p class="text-idt25" data-id="330">int</p><p class="text-idt25" data-id="331">20</p><p class="text-idt25" data-id="332">文章浏览量</p><p class="text-idt25" data-id="333">Comments</p><p class="text-idt25" data-id="334">int</p><p class="text-idt25" data-id="335">20</p><p class="text-idt25" data-id="336">文章评论数</p><p class="text-idt25" data-id="337">createtime</p><p class="text-idt25" data-id="338">int</p><p class="text-idt25" data-id="339">20</p><p class="text-idt25" data-id="340">文章创建时间</p><p class="text-idt25" data-id="341">updatetime</p><p class="text-idt25" data-id="342">int</p><p class="text-idt25" data-id="343">20</p><p class="text-idt25" data-id="344">文章更新时间</p><p class="text-idt25" data-id="345">dest</p><p class="text-idt25" data-id="346">varchar</p><p class="text-idt25" data-id="347">100</p><p class="text-idt25" data-id="348">对文章的简要描述</p><p class="text-idt25" data-id="349">（4）文章分类表存储文章分类的具体名称，表结构设计如下：</p><p class="text-idt25" data-id="350">字段名称</p><p class="text-idt25" data-id="351">数据类型</p><p class="text-idt25" data-id="352">字段长度</p><p class="text-idt25" data-id="353">说明</p><p class="text-idt25" data-id="354">id</p><p class="text-idt25" data-id="355">int</p><p class="text-idt25" data-id="356">5</p><p class="text-idt25" data-id="357">角色ID(主键)</p><p class="text-idt25" data-id="358">name</p><p class="text-idt25" data-id="359">varchar</p><p class="text-idt25" data-id="360">20</p><p class="text-idt25" data-id="361">角色名称</p><p class="text-idt25" data-id="362">dest</p><p class="text-idt25" data-id="363">varchar</p><p class="text-idt25" data-id="364">20</p><p class="text-idt25" data-id="365">角色描述</p><p class="text-idt25" data-id="366">permission_list</p><p class="text-idt25" data-id="367">varchar</p><p class="text-idt25" data-id="368">255</p><p class="text-idt25" data-id="369">权限列表</p><p class="text-idt25" data-id="370">各个表之间的关系如下图数据库模型所示：</p><p class="text-idt25" data-id="371">数据库模型</p><p class="text-idt25" data-id="372">接口</p><p class="text-idt25" data-id="373">http://www.shirdon.com/?p=426 参考网址</p><p class="text-idt25" data-id="374">系统实现</p><p class="text-idt25" data-id="375">注册功能的实现</p><p class="text-idt25" data-id="376">将注册作为一个公共的组件独立出来，成为一个vue文件，用户通过填写简单的信息以及设置登录密码即可完成注册。</p><p class="text-idt25" data-id="377">登录功能的具体实现</p><p class="text-idt25" data-id="378">登录分为前台的登录与后台的登录，两个登录是公用一个组件，通过传入参数的不同去执行不同的登录方法跳转不同的页面。首先前台的用户输入账号和密码，与数据库的用户表里的数据进行对比，若存在则登录成功，跳转到博客前台首页，显示登录状态，可以对文章进行评论。前台登录如下图：</p><p class="text-idt25" data-id="379">/</p><p class="text-idt25" data-id="380">前台登录</p><p class="text-idt25" data-id="381">后台管理系统的登录同前台登录逻辑相同只是最后跳转的页面不同。后台登录如下图：</p><p class="text-idt25" data-id="382">/</p><p class="text-idt25" data-id="383">后台登录</p><p class="text-idt25" data-id="384">前台文章列表的实现</p><p class="text-idt25" data-id="385">通过不同的参数传递从api获得对应参数的文章数据，在前台进行展示。用户浏览文章与文章列表。通过对分类的选择改变api的参数，获取不同分类下的文章。</p><p class="text-idt25" data-id="386">/</p><p class="text-idt25" data-id="387">后台管理系统的实现</p><p class="text-idt25" data-id="388">后台实现对文章的增删查改，对文章列表的增删查改，对用户的查看和封禁以及对评论的查看和封禁。文章管理，分类管理，用户管理，评论管理都通过axios获取数据，然后通过对状态的修改来表示是可用还是不可用，是存在还是删除。</p><p class="text-idt25" data-id="389">/</p><p class="text-idt25" data-id="390">后台管理系统</p><p class="text-idt25" data-id="391">组件及路由设计</p><p class="text-idt25" data-id="392">本系统使用vue-router进行系统的路由管理。Vue Router 是 Vue.js 官方的路由管理器。我们需要将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。</p><p class="text-idt25" data-id="393">本系统的项目结构如下图所示。所有的页面级的组件都放置在views文件夹下，一个文件夹或文件对应一个功能页面，公共组件或者每个页面所需要的组件放置在components文件夹下。本系统的路由设计，使用了 vue- router的 history模式与路由嵌套，在页面中子路由通过[ router- view][/ router- view]标签呈现内容和实现路由变化。</p><p class="text-idt25" data-id="394">项目结构图</p><p class="text-idt25" data-id="395">axios封装</p><p class="text-idt25" data-id="396">在JavaScript中发出HTTP请求的方法有很多，比如：Ajax，jQuery中的方法（$.ajax，$.get，$.post等），axios，Fetch等。本系统选用axios进行数据请求。</p><p class="text-idt25" data-id="397">在 vue项目中，和后台交互获取数据这块，我们通常使用的是 axios库，它是基于 promise的 http库，是可运行在浏览器端和 node. js中。他有很多优秀的特性，例如拦截请求和响应、取消请求、转换json、客户端防御XSRF等。</p><p class="text-idt25" data-id="398">本次使用对axios进行了封装，封装为request.js本质上返回了一个Promise。Promise 是一种对异步操作的封装，可以通过独立的接口添加在异步操作执行成功、失败时执行的方法。当数据有返回并且返回的状态码是成功时，进入Promise的then中执行相应的操作，或是不是成功或者没有数据返回时，在catch中处理错误的情况。</p><p class="text-idt25" data-id="399">主要代码：</p><p class="text-idt25" data-id="400">import axios from ’axios’;</p><p class="text-idt25" data-id="401">import qs from ’qs’;</p><p class="text-idt25" data-id="402">import { getCurrentEnv } from ’./index’;</p><p class="text-idt25" data-id="403">const baseURL = getCurrentEnv();</p><p class="text-idt25" data-id="404">// create an axios instance</p><p class="text-idt25" data-id="405">const service = axios.create({</p><p class="text-idt25" data-id="406">baseURL， // api 的 base_url</p><p class="text-idt25" data-id="407">timeout: TIME_OUT， // request timeout</p><p class="text-idt25" data-id="408">headers: {</p><p class="text-idt25" data-id="409">’Content-Type’: ’application/x-www-form-urlencoded’，</p><p class="text-idt25" data-id="410">}，</p><p class="text-idt25" data-id="411">});</p><p class="text-idt25" data-id="412">const request = (options) =] {</p><p class="text-idt25" data-id="413">if (/post/i.test(options.method)) {</p><p class="text-idt25" data-id="414">options.data = options.params;</p><p class="text-idt25" data-id="415">delete options.params;</p><p class="text-idt25" data-id="416">}</p><p class="text-idt25" data-id="417">const version = options.customBaseURL;</p><p class="text-idt25" data-id="418">// eslint-disable-next-line</p><p class="text-idt25" data-id="419">options.baseURL = getCurrentEnv(version);</p><p class="text-idt25" data-id="420">return service(options);</p><p class="text-idt25" data-id="421">};</p><p class="text-idt25" data-id="422">export default request;</p><p class="text-idt25" data-id="423">在系统中经常做的一件事就是对请求或响应进行拦截，希望在then或catch处理之前进行一些通用的操作。axios提供了请求拦截（interceptors.request）和响应拦截（interceptors.response）。</p><p class="text-idt25" data-id="424">在请求拦截中判断是否是需要token的接口，若需要就添加上token，并对get，post请求参数传递的方式进行区分。</p><p class="text-idt25" data-id="425">登录拦截</p><p class="text-idt25" data-id="426">使用vue-router的router.beforeEach可以创建一个全局前置守卫。对于需要登录的页面在路由定义时添加meta: {requiresAuth: true}项，来标识当前页面需要登录才可以访问，在vuex里创建isLogined作为已登录标志。然后在这个钩子里判断当前页面是否需要登录，即判断是否存在 meta的 requireAuth标签，存在此标签，代表需要登录，当前若是为登录状态则跳转到登录页面 login，若是已登录则不会执行。可以通过路由守卫实现简单的权限控制。</p><p class="text-idt25" data-id="427">主要代码：</p><p class="text-idt25" data-id="428">router.beforeEach((to， from， next) =] {</p><p class="text-idt25" data-id="429">const { name， meta } = to;</p><p class="text-idt25" data-id="430">const { requiresAuth } = meta;</p><p class="text-idt25" data-id="431">if (!store.state.isLogined) {</p><p class="text-idt25" data-id="432">// 如果是需要登录的页面</p><p class="text-idt25" data-id="433">const needLogin = requiresAuth !localStorage.getItem(’info’); // 从localStorage中读取是否获取了已登录的信息</p><p class="text-idt25" data-id="434">if (needLogin) {</p><p class="text-idt25" data-id="435">next(‘login’);//跳转到登录页面</p><p class="text-idt25" data-id="436">} else {</p><p class="text-idt25" data-id="437">next();</p><p class="text-idt25" data-id="438">}</p><p class="text-idt25" data-id="439">});</p><p class="text-idt25" data-id="440">文献：</p><p class="text-idt25" data-id="441">[1]李宇.前后端分离框架在软件设计中的应用[J].无线互联科技.2018，15(17):41-42.</p><p class="text-idt25" data-id="442">[2]汪彤.基于Node.js的图书共享平台的设计与实现[D].北京邮电大学.2018.</p><p class="text-idt25" data-id="443">[3]梁灏.Vue.js实战[M].清华大学出版社.2017.</p><p class="text-idt25" data-id="444">[4]麦冬.轻量级响应式框架Vue.js应用分析[J].信息与电脑(理论版).2017，(7):58-59.</p><p class="text-idt25" data-id="445">[5]刘红卫.利用Node.js开发前后端分离的系统——以图书馆地方文献系统为例[J].天津科技.2018，45(7):67-70.</p><p class="text-idt25" data-id="446">[6]茆玉庭.基于Node.js和WebSocket的即时通信系统的设计与实现[D].南京邮电大学.2018.</p><p class="text-idt25" data-id="447">[7]程桂花，沈炜，何松林，张珂杰.Node.js中Express框架路由机制的研究[J].工业控制计算机.2016，29(8):101-102.</p><p class="text-idt25" data-id="448">[8]王伶俐，张传国.基于NodeJS+Express框架的轻应用定制平台的设计与实现[J].计算机科学.2017，44(z2):596-599.</p><p class="text-idt25" data-id="449">[9]聂鑫.前端编程与数据库设计的合理运用[J].信息与电脑(理论版).2011，(2):100.</p><p class="text-idt25" data-id="450">[10]陈帅，关玉蓉.基于Java Web的奖助学金系统设计与实现[J].科技广场.2017，(3):190-192.</p><p class="text-idt25" data-id="451">[11]李玉.Vue框架的前端交互性能优化解决方案的研究[D].华中科技大学.2017</p><p class="text-idt25" data-id="452">[12]邹竞莹.Node.JS博客系统的设计与实现[D].黑龙江大学.2016.</p><p class="text-idt25" data-id="453">[13]旷志光，纪婷婷，吴小丽.基于Vue.js的后台单页应用管理系统的研究与实现[J].现代计算机.2017，(30):51-55.</p><p class="text-idt25" data-id="454">[14]邓雯婷.基于Vue.js构建单页面GIS应用的方法研究[J].科技创新与应用.2018，（14）：5-7，10.</p><p class="text-idt25" data-id="455">[15]朱二华.基于Vue.js的Web前端应用研究[J].科技与创新.2017，(20):119-121.</p><p class="text-idt25" data-id="456">[16]王志任.基于Vue.js的开发平台的设计与实现[D].广东工业大学.2018.</p>        <div class="paper-footer">
            <p>检测报告由<a href="http://www.paperpass.com/" target="_black">PaperPass</a>文献相似度检测系统生成</p>
            <p>Copyright © 2007-2019 PaperPass</p>
        </div>
    </div>

</div>
</body>
<script type="text/javascript" src="js/jquery.min.js"></script>
<script type="text/javascript" src="js/Lib.js"></script>
<script type="text/javascript">
    Report.report_id = '5cb3b4d7a5c34mt71';
</script>
<script type="text/javascript">
    (function(System,$){
        var cache = new System.Cache(System.report_id,localStorage);
        $(function(){
            $.each(cache.get(),function(){
                $('[data-id='+this.id+']').addClass('g-font-color green').html(this.text);
            });

        });
    })(Report,jQuery);

</script>
</html>
